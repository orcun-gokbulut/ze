/*ZE_POST_PROCESSOR_START(License)*/
//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//  MapResource.h - Zinek Engine v0.05.00 Build 1024 Source Code                                 
// -------------------------------------------------------------------------------- //
//  Copyright (c) 2007-2009 Y. Orçun GÖKBULUT. All rights reserved.                 //
//                                                                                  //
//                 READ TERMS BELLOW BEFORE TAKING ANY ACTION !                     //
//                                                                                  //
//  These coded instructions, statements, and computer programs contain             //
//  unpublished proprietary information belongs to Y. Orçun GÖKBULUT and they are   //
//  protected by international copyright laws. This file is intellectual property   //
//  of the Y. Orçun GÖKBULUT. Storing this file, using this file, changing content  //
//  of this file, copying or duplicating this file, compiling this file, publishing // 
//  this file to anykind media or network, editing  this file, selling this file,   //
//  booking this file, reading this file are probited without notice and written    //
//  permision of Y. Orçun GÖKBULUT.                                                 //
//  These terms at above can only be changed by Y. Orçun GÖKBULUT.                  //
//                                                                                  //
//  Contact Information:                                                            //
//     Adress : Zinek Code House & Game Studio                                      //                                             
//              Aydinlar Mahallesi.                                                 //
//              Mimar Sokak. 33/5                                                   //
//              06450  Ankara/TURKEY                                                //
//     Phone  : +90 (533) 734 21 22                                                 //
//     E-Mail : contact@zinekengine.com                                             //
//     WWW    : http://www.zinekengine.com                                          //
//                                                                                  //
//*                                                                                *//
//  DESCRIPTION         :                                                           //
//  AUTHOR(S)           : Y. Orçun GÖKBULUT                                         //
//*                                                                                *//
//////////////////////////////////////////////////////////////////////////////////////
/*ZE_POST_PROCESSOR_END()*/

float4	  MaterialParams0			 : register(c0);
float4	  MaterialParams1			 : register(c1);
float4	  MaterialParams2			 : register(c2);
float4	  MaterialParams3			 : register(c3);
float4	  MaterialParams4			 : register(c4);

#define	  MaterialAmbientColor         MaterialParams0.xyz
#define	  MaterialOpasity			   MaterialParams0.w
#define	  MaterialDiffuseColor         MaterialParams1.xyz
#define	  MaterialSpecularColor        MaterialParams2.xyz
#define	  MaterialSpecularFactor	   MaterialParams2.w
#define	  MaterialEmmisiveColor        MaterialParams3.xyz
#define	  MaterialEmmisiveFactor	   MaterialParams3.w
#define	  MaterialReflectionFactor	   MaterialParams4.x
#define	  MaterialRefractionFactor     MaterialParams4.y;
#define	  MaterialDetailMapTiling      MaterialParams4.zw;

float4    LightParameters0           : register(c12);

#define LightColor						LightParameters0.xyz
#define LightIntensity					LightParameters0.w

sampler   DiffuseMap                 : register(s0);
sampler   NormalMap                  : register(s1);
sampler   SpecularMap                : register(s2);
sampler   EmmisiveMap                : register(s3);
sampler   OpacityMap				 : register(s4);
sampler   DetailMap                  : register(s5);
sampler   EnvironmentMap             : register(s6);
sampler   LightMap                   : register(s7);
sampler   ShadowMap                  : register(s8);

struct PS_INPUT
{
	#ifndef ZESHADER_NORMALMAP
		float3 Normal             : TEXCOORD0;
	#endif

	float2 Texcoord           : TEXCOORD1;
	float3 ViewDirection      : TEXCOORD2;
	float4 LightDirection     : TEXCOORD3;

	#ifdef ZESHADER_SHADOWMAP
	//float3 ShadowMapCoord     : TEXCOORD4;
	#endif
};

float4 ps_main(PS_INPUT Input) : COLOR0
{
	float4 OutputColor;

	#ifdef ZESHADER_NORMALMAP
		float3 Normal = (2.0f * tex2D(NormalMap, Input.Texcoord) - 1.0f);
	#else
		float3 Normal = normalize(Input.Normal);
	#endif 

	// Transparancy
	#ifdef ZESHADER_OPASITYMAP
		OutputColor.a = MaterialOpasity * tex2D(OpacityMap, Input.Texcoord).r;
	#else
		#ifdef ZESHADER_DIFFUSEMAP
			OutputColor.a = MaterialOpasity * tex2D(DiffuseMap, Input.Texcoord).a;
		#else
			OutputColor.a = MaterialOpasity;
		#endif
	#endif
		
	float3 ViewDirection = normalize(Input.ViewDirection);
	float3 LightDirection = normalize(Input.LightDirection.xyz);

	float3 HalfVector = normalize(ViewDirection + LightDirection);
	float DiffuseAngularAttenuation = saturate(dot(LightDirection, Normal));
	/*if (DiffuseAngularAttenuation > 0.0f)
	{*/	
		#ifdef ZESHADER_DIFFUSEMAP
			#ifdef ZESHADER_DETAILMAP
				float3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DiffuseMap, Input.Texcoord).rgb * tex2D(DetailMap, Input.Texcoord * MaterialDetailMapTiling);
			#else
				float3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DiffuseMap, Input.Texcoord).rgb;
			#endif
		#else
			#ifdef ZESHADER_DETAILMAP
				float3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DetailMap, Input.Texcoord * MaterialDetailMapTiling);
			#else
				float3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor;
			#endif
		#endif

		float SpecularAngularAttenuation;

		SpecularAngularAttenuation = pow(saturate(dot(HalfVector, Normal)), MaterialSpecularFactor);
		#ifdef ZESHADER_SPECULARMAP
			float3 SpecularColor = SpecularAngularAttenuation * MaterialSpecularColor * tex2D(SpecularMap, Input.Texcoord).rgb;
		#else
			float3 SpecularColor = SpecularAngularAttenuation * MaterialSpecularColor;
		#endif
		OutputColor.rgb = (DiffuseColor + SpecularColor) * LightColor * (Input.LightDirection.w * LightIntensity);
	/*}
	else
		OutputColor.rgb = float3(0.0f, 0.0f, 0.0f);	*/

	return OutputColor;

}