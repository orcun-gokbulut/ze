/*ZEHEADER_START*/
//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
//  Core.h - Zinek Engine v0.04.02 Build 905 Source Code                                 
// -------------------------------------------------------------------------------- //
//  Copyright (c) 2007-2008 Zinek Engine group.                                     //
//  All rights reserved.                                                            //
//                                                                                  //
//                 READ TERMS BELLOW BEFORE TAKING ANY ACTION !                     //
//                                                                                  //
//  These coded instructions, statements, and computer programs contain             //
//  unpublished proprietary information written by Zinek Engine group and they are  //
//  protected by international copyright laws. This file is intellectual property   //
//  of the Zinek Engine group and author(s). Storing this file, using this file,    //
//  compiling this file, publishing this file to anykind media or network, editing  //
//  this file, selling this file, reading this file is probited without notice and  //
//  written permision of Y. Orcun Gokbulut. These terms at above can only be        //
//  changed by Y. Orcun GOKBULUT.                                                   //
//  author(s).                                                                      //
//*                                                                                *//
//  DESCRIPTION         :                                                           //
//  AUTHOR(S)           : Y. Orcun GOKBULUT                                         //
//*                                                                                *//
//////////////////////////////////////////////////////////////////////////////////////
/*ZEHEADER_END*/

#ifdef ZESHADER_COMPONENT0
#define ZESHADER_SKINTRANFORMATION
#endif
#ifdef ZESHADER_COMPONENT1
#define ZESHADER_DIFFUSEMAP
#endif
#ifdef ZESHADER_COMPONENT2
#define ZESHADER_NORMALMAP
#endif
#ifdef ZESHADER_COMPONENT3
#define ZESHADER_SPECULARMAP
#endif
#ifdef ZESHADER_COMPONENT4
#define ZESHADER_EMMISIVEMAP
#endif
#ifdef ZESHADER_COMPONENT5
#define ZESHADER_OPASITYMAP
#endif
#ifdef ZESHADER_COMPONENT6
#define ZESHADER_DETAILDIFFUSEMAP
#endif
#ifdef ZESHADER_COMPONENT7
#define ZESHADER_DETAILNORMALMAP
#endif
#ifdef ZESHADER_COMPONENT8
#define ZESHADER_REFLECTION
#endif
#ifdef ZESHADER_COMPONENT9
#define ZESHADER_REFRACTION
#endif
#ifdef ZESHADER_COMPONENT10
#define ZESHADER_LIGHTMAP
#endif
#ifdef ZESHADER_COMPONENT11
#define ZESHADER_DISTORTIONMAP
#endif

float4	  MaterialParams0			 : register(c0);
float4	  MaterialParams1			 : register(c1);
float4	  MaterialParams2			 : register(c2);
float4	  MaterialParams3			 : register(c3);
float4	  MaterialParams4			 : register(c4);

#define	  MaterialAmbientColor         MaterialParams0.xyz
#define	  MaterialOpasity			   MaterialParams0.w
#define	  MaterialDiffuseColor         MaterialParams1.xyz
#define	  MaterialSpecularColor        MaterialParams2.xyz
#define	  MaterialSpecularFactor	   MaterialParams2.w
#define	  MaterialEmmisiveColor        MaterialParams3.xyz
#define	  MaterialEmmisiveFactor	   MaterialParams3.w
#define	  MaterialReflectionFactor	   MaterialParams4.x
#define	  MaterialRefractionFactor     MaterialParams4.y;
#define	  MaterialDetailMapTiling      MaterialParams4.zw;

float4    LightColor                 : register(c12);
float     LightIntensity             : register(c13);
float2	  ShadowMapTexelDimensions	 : register(c14);
sampler   DiffuseMap                 : register(s0);
sampler   NormalMap                  : register(s1);
sampler   SpecularMap                : register(s2);
sampler   EmmisiveMap                : register(s3);
sampler   OpacityMap				 : register(s4);
sampler   DetailMap                  : register(s5);
sampler   EnvironmentMap             : register(s6);
sampler   LightMap                   : register(s7);
sampler   ShadowMap                  : register(s8);
sampler	  ProjectionMap				 : register(s9);

static const float2  PCFKernel[8] =
{
	{0.0f, -1.0f},
	{0.0f, 1.0f},
	{-1.0f, 0.0f},
	{1.0f, 0.0f},
	{-1.0f, -1.0f},
	{-1.0f, 1.0f},
	{1.0f, -1.0f},
	{1.0f, 1.0f}
};

#define ZESHADER_SHADOW_PCF
inline void CalculateShadow(in float4 ShadowTexcoord, in float Depth, out float ShadowFactor)
{
	#ifdef ZESHADER_SHADOW_PCF
		float2 ProjTexcoord = float2(ShadowTexcoord.xy / ShadowTexcoord.w);
		float4 Samples = Depth < float4(
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[0]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[1]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[2]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[3]).x);
		
		ShadowFactor = dot(Samples, float4(0.1125f, 0.1125f, 0.1125f, 0.1125f));

		Samples = Depth < float4(
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[4]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[5]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[6]).x,
			tex2D(ShadowMap, ProjTexcoord + ShadowMapTexelDimensions * PCFKernel[7]).x);
		
		ShadowFactor += dot(Samples, float4(0.1125f, 0.1125f, 0.1125f, 0.1125f));
	#elif defined(ZESHADE_SHADOW_PCFBILINEAR)
		ShadowFactor = 0.0f;
	#else
		#ifdef ZESHADER_SHADOW_NVIDIA
			ShadowFactor = tex2Dproj(ShadowMap, ShadowTexcoord).x;
		#elif defined(ZESHADER_SHADOW_ATI)
			ShadowFactor = 0.0f;
		#else
			ShadowFactor = tex2Dproj(ShadowMap, ShadowTexcoord).x > Depth ? 1.0f : 0.0f;
		#endif
	#endif

}

inline void CalculatePointLight(in float3 Normal,
								in float3 LightDirectionUN,
								in float  DistanceAttenuation,
								in float3 ViewDirection,
								in float LightIntensity,
								in float3 LightColor,
								in float2 Texcoord,
								inout float3 OutputColor)
{
	float3 LightDirection = normalize(LightDirectionUN);
	float3 HalfVector = normalize(ViewDirection + LightDirection);
	float DiffuseAngularAttenuation = saturate(dot(LightDirection, Normal));
	
	if (DiffuseAngularAttenuation > 0.0f)
	{
		#ifdef ZESHADER_DIFFUSEMAP
			#ifdef ZESHADER_DETAILMAP
				half3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DiffuseMap, Texcoord).rgb * tex2D(DetailMap, Texcoord * MaterialDetailMapTiling);
			#else
				half3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DiffuseMap, Texcoord).rgb;
			#endif
		#else
			#ifdef ZESHADER_DETAILMAP
				half3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor * tex2D(DetailMap, Texcoord * MaterialDetailMapTiling);
			#else
				half3 DiffuseColor =  DiffuseAngularAttenuation * MaterialDiffuseColor;
			#endif
		#endif

		float SpecularAngularAttenuation = pow(saturate(dot(HalfVector, Normal)), MaterialSpecularFactor);
		#ifdef ZESHADER_SPECULARMAP
			half3 SpecularColor = SpecularAngularAttenuation * MaterialSpecularColor * tex2D(SpecularMap, Texcoord).rgb;
		#else
			half3 SpecularColor = SpecularAngularAttenuation * MaterialSpecularColor;
		#endif

		OutputColor = (DiffuseColor + SpecularColor) * LightColor * DistanceAttenuation * LightIntensity;
	}
	else
	{
		discard;
		OutputColor = half3(0.0f, 0.0f, 0.0f);
	}
}

struct PS_INPUT
{
	#ifndef ZESHADER_NORMALMAP
		float3 Normal         : TEXCOORD0;
	#endif

	float2 Texcoord           : TEXCOORD1;
	float3 ViewDirection      : TEXCOORD2;
	float4 LightDirection     : TEXCOORD3;
	float4 ProjTexcoord       : TEXCOORD4;
	float4 Position			  : TEXCOORD5;
};

half4 ps_main(PS_INPUT Input) : COLOR0
{	
	#ifdef ZESHADER_OPASITYMAP
		float4 OutputColor = half4(0.0f, 0.0f, 0.0f, MaterialOpasity * tex2D(OpacityMap, Input.Texcoord).r);
	#else
		#ifdef ZESHADER_DIFFUSEMAP
			float4 OutputColor = half4(0.0f, 0.0f, 0.0f, MaterialOpasity * tex2D(DiffuseMap, Input.Texcoord).a);
		#else
			float4 OutputColor = half4(0.0f, 0.0f, 0.0f, MaterialOpasity);
		#endif
	#endif

	#ifdef ZESHADER_SHADOWMAP
		float ShadowFactor;
		float Depth = Input.Position.z / Input.Position.w;
		CalculateShadow(Input.ProjTexcoord, Depth, ShadowFactor);
		if (ShadowFactor == 0)
		{
			discard;
			return float4(0.0f, 0.0f, 0.0f, 1.0f);
		}
	#endif

	#ifdef ZESHADER_NORMALMAP
		float3 Normal = (2.0f * tex2D(NormalMap, Input.Texcoord) - 1.0f);
	#else
		float3 Normal = normalize(Input.Normal);
	#endif 

	float3 ViewDirection = normalize(Input.ViewDirection);

	CalculatePointLight(Normal, Input.LightDirection.xyz, Input.LightDirection.w, ViewDirection, LightIntensity, LightColor * tex2Dproj(ProjectionMap, Input.ProjTexcoord).rgb, Input.Texcoord, OutputColor.rgb);

	#ifdef ZESHADER_SHADOWMAP
		OutputColor.rgb *= ShadowFactor;
	#endif

	return OutputColor;

}